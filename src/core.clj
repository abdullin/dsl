(ns core
  (:require
   [clojure.java.io :as io]
   [clojure.string :as str])
  (:gen-class))

(defn switch-case [s fn]
  (let [[first & rest] s]
    (str/join (cons (fn first) rest))))

(defn camel [s] (switch-case s str/lower-case))
(defn pascal [s] (switch-case s str/upper-case))


(defn load-config [filename]
  (with-open [r (io/reader filename)]
    (read (java.io.PushbackReader. r))))


(defn to-string-
  "Takes a string and a collection of fields to create a .NET format string"
  [s fields]
  (reduce
   (fn [acc field]
     (let [
           [s matched idx] acc
           prop (:prop field)
           id (or (:id field) prop)
           regex (re-pattern (str "(?i)\\{(" (str/join "|" [prop (name id)]) ")\\}"))
           ]
       (if (re-find regex s)
         [(str/replace s regex (str "{" idx "}")) (conj matched prop) (inc idx)]
         [s matched idx]))
     )
   [s [] 0] fields))


(defn field-
  ([type] (field- type type))
  ([type name] {:name (camel (str name)) :type (str type) :prop (pascal (str name))})
  ([type arr name] (assoc (field- (str type "[]") name) :array-of (str type))))

(defn unwrap-field-
  "field can be :const [type] [type name] [type [] name]"
  [index fld const]
  (let [
        tuple (get const fld fld)
        id (if-not (seq? fld) fld)
        ]
    (assoc (apply field- tuple) :id id :order (inc index))))

(defn unwrap-message- [msg agg const]
  (let [
        [kind id fs txt] msg
        fs (if (= kind :rec) fs  (concat (:common agg) fs))
        ]
    {
     :name id
     :fields (filter some? (map-indexed #(if %2 (unwrap-field- %1 %2 const)) fs)) 
     :string txt
     :kind kind
     :base (kind agg)
     }
    ))

(defn unwrap-agg- [file-const agg]
  (let [
        {:keys [event command const messages]} agg
        const (merge file-const const)
        ]
    (println (str "Processing aggregate" (:name agg)))
    (assoc agg :messages (map #(unwrap-message- % agg const) messages) )))

(defn unwrap- [cfg]
  (let [{:keys [const aggs]} cfg]
    (assoc cfg :aggs (map #(unwrap-agg- const %) aggs))))

(defn print-dsl [cfg ln]
  (let [{:keys [file namespace prefix using const aggs extern]} cfg]
    (doseq [u using]
      (ln "using %s;\n" (str u)))
    (ln "\n// ReSharper disable PartialTypeWithSinglePart\n")
    (ln "// ReSharper disable UnusedMember.Local\n")
    (ln "namespace %s\n{\n\t#region Generated by Lokad Code DSL\n" (str namespace))
    (doseq [g aggs]
      (let [ {:keys [name common command event const2 messages] } g]
        (doseq [m messages  :let [{:keys [name base fields string]} m] ]
          (ln "\t[DataContract(Namespace = \"%s\")]\n" extern)
          (ln "\tpublic partial class %s%s\n\t{\n" name (if base (str " : " base) ""))
          
          (doseq [{:keys [order prop type]} fields]
            (ln "\t\t[DataMember(Order = %d)] public %s %s { get; private set; }\n" order type prop))
          
                                        ; ctors only if we have fields
          (when (seq fields)
            (ln "\t\t") ; "old code demands
            (ln "\n\t\t%s ()" name)
            (let [arrays (filter #(:array-of %) fields)]
              (if (seq arrays)
                (do
                  (ln " \n{") ; this is how old code works
                  (doseq [{:keys [prop array-of]} arrays]
                    (ln "\n\t\t\t%s = new %s[0];" prop array-of))
                    (ln "\n\t\t}\n")
                    )
                (ln " {}\n")
                )
              )
            (ln "\t\tpublic %s (%s)\n\t\t{\n" name (str/join  ", " (map #(str (:type %1) " " (camel (:name %1))) fields)))
            (doseq [{:keys [name prop]} fields]
              (ln "\t\t\t%s = %s;\n" prop (camel name)))
            (ln "\t\t}\n")
            )
          
          (if string
            (let [[fixed names] (to-string- string fields)]
              (do
                (ln "\t\t\n\t\tpublic override string ToString()\n\t\t{\n")
                (ln "\t\t\treturn string.Format(@\"%s\", %s);\n\t\t}\n" fixed (str/join ", " names)))))
          
          (ln "\t}\n"))
        ))
    (doseq [g (reverse aggs)]
      (let [{:keys [name messages]} g]
        (when (some? name)
          (ln "\t\n\tpublic interface I%sApplicationService\n\t{\n" name)
          (doseq [m (filter #(= 'cmd (:kind %)) messages)]
            (ln "\t\tvoid When(%s c);\n" (:name m)))
          (ln "\t}\n")
          
          (ln "\t\n\tpublic interface I%sState\n\t{\n" name)
          (doseq [m (filter #(= 'evt (:kind %)) messages)]
            (ln "\t\tvoid When(%s e);\n" (:name m)))
          (ln "\t}\n"))))
    (ln "\t#endregion\n}\n")
    ))

(defn walk [dirpath pattern]
  (doall (filter #(re-matches pattern (.getName %))
                 (file-seq (io/file dirpath)))))

(defn -main [& args]
  (let [
        [dir] args
        dir (or dir ".")
        ]
    (doseq [file (walk dir #".*\.edn")]
      (let [
            filename (.getPath file)
            cfg (load-config filename)
            data (unwrap- cfg)
            out  (io/file (.getParent file)  (str (:file cfg)))
            ]
        (print (str "Generating " filename  " to " out "..."))
        (with-open [w (io/writer (str out))]
          (let [w (fn [s & args]
                    (let [s (-> s
                                (str/replace "\t" "    ")
                                (str/replace "\n" "\r\n"))]
                      (.write w (apply format (cons s args))))

                    )]
            (print-dsl data w)
            ))
        (println "Done")
        ))))
